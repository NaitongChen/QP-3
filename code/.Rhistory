remotes::install_github("ubc-stat/stat-406-rpackage")
Stat406::test_latex_installation()
getwd9)
getwd()
setwd("C:/projects/Qualifying papers/QP-3/code")
source(helpers.R)
source("helpers.R")
beta = rep(0, p)
p = 20
n = 10
beta = rep(0, p)
beta
beta[1]
beta[1], beta[15] = 1
# load helper functions
source("helpers.R")
p = 20
n = 10
beta = rep(0, p)
beta[1] = 1
beta[2] = -1
beta[15] = 1
beta[16] = -1
beta
# load helper functions
source("helpers.R")
p = 20
n = 10
beta = rep(0, p)
beta[1] = 1
beta[2] = -1
beta[19] = 1
beta[20] = -1
?randn
?rrand
?rand
# load helper functions
source("helpers.R")
p = 20
n = 10
beta = rep(0, p)
beta[1] = 1
beta[2] = -1
beta[19] = 1
beta[20] = -1
signal = 1
mu_x = 0
sigma_x = 1
sigma_y = 1
rnorm(n*p, mu_x, sigma_x)
?matrix
X = matrix(rnorm(n*p, mu_x, sigma_x), nrow=n)
X
signal * beta
X %*% (signal * beta)
X[1,1]-X[1,2]+X[1,19]-X[1,20]
y
y = X %*% (signal * beta)
y+3
generate_data <- function(n, p, beta, signal, mu_x, sigma_x, sigma_y) {
X = matrix(rnorm(n*p, mu_x, sigma_x), nrow=n)
y = X %*% (signal * beta) + rnorm(n, 0, sigma_y)
retur(X,y)
}
generate_data(n, p, beta, signal, mu_x, sigma_x, sigma_y)
generate_data <- function(n, p, beta, signal, mu_x, sigma_x, sigma_y) {
X = matrix(rnorm(n*p, mu_x, sigma_x), nrow=n)
y = X %*% (signal * beta) + rnorm(n, 0, sigma_y)
return(X,y)
}
generate_data <- function(n, p, beta, signal, mu_x, sigma_x, sigma_y) {
X = matrix(rnorm(n*p, mu_x, sigma_x), nrow=n)
y = X %*% (signal * beta) + rnorm(n, 0, sigma_y)
return(X,y)
}
a,b = generate_data(n, p, beta, signal, mu_x, sigma_x, sigma_y)
a = generate_data(n, p, beta, signal, mu_x, sigma_x, sigma_y)
X,y
X
y
list(X,y)
generate_data <- function(n, p, beta, signal, mu_x, sigma_x, sigma_y) {
X = matrix(rnorm(n*p, mu_x, sigma_x), nrow=n)
y = X %*% (signal * beta) + rnorm(n, 0, sigma_y)
return(list(X,y))
}
a = generate_data(n, p, beta, signal, mu_x, sigma_x, sigma_y)
a[1]
a[2]
X
nrow(X)
sample(1:n, n)
floor(3.3)
X[1:split_size,]
X[1:5,]
X[1:5,:]
X[1:5,]
X[6:,]
a = 0.5
n = nrow(X)
split_size = floor(n * a)
shuffle_inds = sample(1:n, n)
first_half = shuffle_inds[1:split_size]
second_half = shuffle_inds[split_size+1:n]
X[first_half,]
X[6,]
p = ncol(X)
p
library(glmnet)
?cv.glmnet
n = nrow(X)
cvfit <- cv.glmnet(X, y, type.measure = "mse", nfolds = n)
n
y
drop(y)
n = nrow(X)
cvfit <- cv.glmnet(X, drop(y), type.measure = "mse", nfolds = n)
cvfit <- cv.glmnet(X, drop(y), type.measure = "mse", nfolds = 2)
cvfit <- cv.glmnet(X, drop(y), type.measure = "mse", nfolds = 3)
cvfit <- cv.glmnet(X, drop(y), type.measure = "mse", nfolds = 4)
?glmnet
cvfit <- cv.glmnet(X, drop(y), type.measure = "mse", family = "gaussian", alpha = 1, nfolds = n)
# load helper functions
source("helpers.R")
p = 20
n = 100
beta = rep(0, p)
beta[1] = 1
beta[2] = -1
beta[19] = 1
beta[20] = -1
signal = 1
mu_x = 0
sigma_x = 1
sigma_y = 1
a = 0.5
dat = generate_data(n, p, beta, signal, mu_x, sigma_x, sigma_y)
X = dat[1]
y = dat[2]
n = nrow(X)
n
X
X
nrow(X)
X
# load helper functions
source("helpers.R")
p = 20
n = 100
beta = rep(0, p)
beta[1] = 1
beta[2] = -1
beta[19] = 1
beta[20] = -1
signal = 1
mu_x = 0
sigma_x = 1
sigma_y = 1
a = 0.5
dat = generate_data(n, p, beta, signal, mu_x, sigma_x, sigma_y)
X = dat[[1]]
y = dat[[2]]
X
n = nrow(X)
n
cvfit <- cv.glmnet(X, drop(y), type.measure = "mse", family = "gaussian", alpha = 1, nfolds = n)
cvfit <- cv.glmnet(X, drop(y), type.measure = "mse", family = "gaussian", alpha = 1, nfolds = 10)
cvfit <- cv.glmnet(X, drop(y), type.measure = "mse", family = "gaussian", alpha = 1, nfolds = n)
data(iris)
CVGLM <- cv.glmnet(as.matrix(iris[,-5]),
iris[,5],
nfolds = nrow(iris),
type.measure = "class",
alpha = 0,
grouped = FALSE,
family = "multinomial")
?cv.glmnet
cvfit <- cv.glmnet(X, drop(y), type.measure = "mse", family = "gaussian", alpha = 1, nfolds = n, grouped = FALSE)
lam = cvfit.lambda.1se
cvfit
cvfit$lambda.1se
final_fit <- glmnet(X, drop(y), type.measure = "mse", family = "gaussian", alpha = 1)
final_fit
final_fit <- glmnet(X, drop(y), type.measure = "mse", family = "gaussian", alpha = 1, lambda = lam)
lam = cvfit$lambda.1se
final_fit <- glmnet(X, drop(y), type.measure = "mse", family = "gaussian", alpha = 1, lambda = lam)
final_fit
final_fit$beta
final_fit$beta
final_fit$beta
final_fit$beta
final_fit$beta > 0
test = 1:20
test
test[final_fit$beta > 0]
drop(final_fit$beta)
drop(final_fit$beta) > 0
test[drop(final_fit$beta) > 0]
test[drop(final_fit$beta) != 0]
(1:20)[drop(final_fit$beta) != 0]
test = data.frame(X, y)
test
lm(y ~ ., data=test)
?glmnet
n
p
n = nrow(X)
p = ncol(X)
cvfit <- cv.glmnet(X, drop(y), type.measure = "mse", family = "gaussian",
alpha = 1, nfolds = n, grouped = FALSE, intercept = FALSE)
final_fit <- glmnet(X, drop(y), type.measure = "mse", family = "gaussian",
alpha = 1, lambda = cvfit$lambda.1se, grouped = FALSE,
intercept = FALSE)
final_fit$beta
final_fit <- glmnet(X, drop(y), type.measure = "mse", family = "gaussian",
alpha = 1, lambda = cvfit$lambda.1se, grouped = FALSE)
final_fit$beta
final_fit$nobs
final_fit$a0
final_fit <- glmnet(X, drop(y), type.measure = "mse", family = "gaussian",
alpha = 1, lambda = cvfit$lambda.1se, grouped = FALSE,
intercept = FALSE)
final_fit$a0
selected
n = nrow(X)
p = ncol(X)
cvfit <- cv.glmnet(X, drop(y), type.measure = "mse", family = "gaussian",
alpha = 1, nfolds = n, grouped = FALSE, intercept = FALSE)
final_fit <- glmnet(X, drop(y), type.measure = "mse", family = "gaussian",
alpha = 1, lambda = cvfit$lambda.1se, grouped = FALSE,
intercept = FALSE)
selected <- (1:p)[drop(final_fit$beta) != 0]
selected
X = X[, selected]
df = data.frame(X,y)
beta_hat = lm(y~.-1, data = df)
beta_hat
I(2)
X
t(X)
t(X) %*% X
inv(t(X) %*% X)
inverse(t(X) %*% X)
solve(t(X) %*% X)
solve(t(X) %*% X) %*% (t(X) %*% X)
selected
length(selected)
p = ncol(X)
p
qnorm(0.975)
alpha=0.05
qnorm(alpha/2)
qnorm((1-alpha)/2)
qnorm(1-(alpha/2))
z = qnorm(1-(alpha/2))
z
beta_hat
drop(beta_hat)
length(beta_hat)
beta_hat$coefficients
beta_hat = lm(y~.-1, data = df)$coefficients
beta_hat
length(beta_hat)
CIs = matrix(rep(0, p*2), nrow = p)
CIs
X = X[, selected]
X
p = ncol(X)
p
df = data.frame(X,y)
beta_hat = lm(y~.-1, data = df)$coefficients
cov = solve(t(X) %*% X) %*% t(X) %*% (sigma_y^2 * diag(p)) * X * solve(t(X) %*% X)
diag(p)
sigma_y
(sigma_y^2 * diag(p))
(sigma_y^2 * diag(p))
solve(t(X) %*% X)
solve(t(X) %*% X) %*% t(X)
n = nrow(X)
beta_hat = lm(y~.-1, data = df)$coefficients
cov = solve(t(X) %*% X) %*% t(X) %*% (sigma_y^2 * diag(n)) * X * solve(t(X) %*% X)
solve(t(X) %*% X) %*% t(X)
(sigma_y^2 * diag(n))
solve(t(X) %*% X) %*% t(X) %*% (sigma_y^2 * diag(n))
cov = solve(t(X) %*% X) %*% t(X) %*% (sigma_y^2 * diag(n)) %*% X %*% solve(t(X) %*% X)
z = qnorm(1-(alpha/2))
CIs = matrix(rep(0, p*2), nrow = p)
for (i in 1:p) {
CIs[i,1] = beta_hat[i] - z * cov[i,i]
CIs[i,2] = beta_hat[i] + z * cov[i,i]
}
beta_hat
CIs
(solve(t(X) %*% X) %*% t(X) %*% (sigma_y^2 * diag(n))
%*% X %*% solve(t(X) %*% X))
(solve(t(X) %*% X) %*% t(X) %*% (sigma_y^2 * diag(n)) %*% X %*% solve(t(X) %*% X))
